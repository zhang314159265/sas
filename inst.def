Name (as shown in Intel doc), OPCode (big endian), Description
============
add, 0x01, "Add r32 to r/m32"
add, 0x83/0, "Add sign extended imm8 to r/m32"
and, 0x83/4, "And imm8 and r/m32 (sign-extended)"
call, 0xe8, "Call relative using 32 bit displacement"
cdq, 0x99, "Sign extend dword in eax to quadword in edx:eax."
cltd, 0x99, "alias to cdq"
cmovns, 0x0f49, "Conditional move r/m32 to r32 if NS"
cmp, 0x39, "Compare 'r/m32 - r32'"
cmp, 0x3b, "Compare 'r32 - r/m32'"
cmp, 0x83/7, "Compare 'r/m32 - imm8'"
div, 0xf7/6, "unsigned div by r/m32"
idiv, 0xf7/7, "signed div by r/m32"
imul, 0x0faf, "Signed multiply. Two-operand form. Multiply r32 (dst) and r/m32, store the truncated result back to r32"
int3, 0xcc, "trigger a breakpoint"
int, 0xcd, "imm8 represents the interrupt vector"
ja, 0x77, "relative jump using 8 bit displacement, if cc=A"
jbe, 0x76, "relative jump using 8 bit displacement, if cc=BE"
je, 0x74, "relative jump using 8 bit displacement, if cc=E"
jl, 0x7c, "relative jump using 8 bit displacement, if cc=L"
jl, 0x0f8c, "relative jump using 32 bit displacement, if cc=L"
jle, 0x7e, "relative jump using 8 bit displacement if cc=LE"
jmp, 0xe9, "relative jump using 32 bit displacement"
jmp, 0xeb, "relative jump using 8 bit displacement"
jne, 0x75, "relative jump using 8 bit displacement if cc=NE"
lea, 0x8d, "Load the effective address of the memory operand to register"
leave, 0xc9, "Short cut for 'mov %ebp, %esp; pop %ebp'"
mov, 0x89, "store: move r32 to r/m32"
mov, 0x8b, "load: move r/m32 to r32"
mov, 0xa1, "mov dword from memory to eax. memory is specified by 32 bit displacement"
mov, 0xa3, "mov eax to dword in memory. memory is specified by 32 bit displacement"
mov, 0xb8+, "move imm32 to r32"
mov, 0xc6/0, "move imm8 to r/m8"
mov, 0xc7/0, "Move imm32 to r/m32"
movzx, 0x0fb6, "Move zero_extend(r/m8) to r32"

neg, 0xf7/3, "Negate r/m32"

pop, 0x58+, "Pop top of stack into r32"
popa, 0x61, "Pop all"
push, 0x50+, "Push r32 into the stack"
push, 0x68, "Push imm32 to the stack"
push, 0x6a, "Push imm8 to the stack"
push, 0xff/6, "Push r/m32 to the stack"
pusha, 0x60, "Push all"

ret, 0xc3, "Return to the caller"
shl, 0xd3/4, "logical left shift: shift r/m32 left cl times"
sub, 0x29, "r/m32 - r32"
sub, 0x2b, "r32 - r/m32"
sub, 0x83/5, "Substract sign-extended imm8 from r/m32"
test, 0x84, "AND r8 with r/m8 (dst)"
test, 0x85, "AND r32 with r/m32 (dst)"


=========== below are for floating pointer instructions
faddp, 0xdec0+, "Add ST(0) to ST(i) then pop"
fcomip, 0xdff0+, "Set eflags base on 'ST(0) - ST(i)'. Then pop register stack"
# fdivp, 0xdef8+, "ST(i) = ST(i) / ST(0), then pop"
fdivrp, 0xdef0+, "ST(i) = ST(0) / ST(i), then pop. The mnemonic show in asm may be fdivp"
fild, 0xdb/0, "Push integer from m32int onto the FPU register stack"
fld, 0xdd/0, "Push m64fp onto the FPU register stack"
fld1, 0xd9e8, "Push +1.0 onto the FPU register stack"
fldz, 0xd9ee, "Push +0.0 onto the FPU register stack"
fstp, 0xdd/3, "Copy ST(0) to m64fp and pop register stack"
fstp, 0xddd8+, "Copy ST(0) to ST(i) and then pop"
fxch, 0xd9c8+, "Exchange ST(0) and ST(i)"

