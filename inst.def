Name (as shown in Intel doc), OPCode (big endian), Description
============
add, 0x01, "Add r32 to r/m32"
add, 0x05, "Add imm32 to eax"
add, 0x83/0, "Add sign extended imm8 to r/m32"
and, 0x25, "And imm32 and eax"
# and, 0x81/4, "And imm32 and r/m32"
and, 0x83/4, "And imm8 and r/m32 (sign-extended)"
call, 0xe8, "Call relative using 32 bit displacement"
cdq, 0x99, "Sign extend dword in eax to quadword in edx:eax."
cltd, 0x99, "alias to cdq"
cmovns, 0x0f49, "Conditional move r/m32 to r32 if NS"
cmp, 0x39, "Compare 'r/m32 - r32'"
cmp, 0x3b, "Compare 'r32 - r/m32'"
cmp, 0x80/7, "Compare 'r/m8 - imm8'"
cmp, 0x83/7, "Compare 'r/m32 - imm8'"
div, 0xf7/6, "unsigned div by r/m32"
idiv, 0xf7/7, "signed div by r/m32"
imul, 0x0faf, "Signed multiply. Two-operand form. Multiply r32 (dst) and r/m32, store the truncated result back to r32"
int3, 0xcc, "trigger a breakpoint"
int, 0xcd, "imm8 represents the interrupt vector"
ja, 0x77, "relative jump using 8 bit displacement, if cc=A"
jb, 0x72, "relative jump using 8 bit displacement, if cc=B"
jbe, 0x76, "relative jump using 8 bit displacement, if cc=BE"
je, 0x0f84, "relative jump using 32 bit displacement, if cc=E"
je, 0x74, "relative jump using 8 bit displacement, if cc=E"
jg, 0x7f, "relative jump using 8 bit displacement, if cc=G"
jl, 0x7c, "relative jump using 8 bit displacement, if cc=L"
jl, 0x0f8c, "relative jump using 32 bit displacement, if cc=L"
jle, 0x7e, "relative jump using 8 bit displacement if cc=LE"
jle, 0x0f8e, "relative jump using 32 bit displacement if cc=LE"
jmp, 0xe9, "relative jump using 32 bit displacement"
jmp, 0xeb, "relative jump using 8 bit displacement"
jne, 0x75, "relative jump using 8 bit displacement if cc=NE"
js, 0x78, "relative jump using 8 bit displacement if cc=S"
lea, 0x8d, "Load the effective address of the memory operand to register"
leave, 0xc9, "Short cut for 'mov %ebp, %esp; pop %ebp'"
mov, 0x88, "store: move r8 to r/m8"
mov, 0x89, "store: move r32 to r/m32"
mov, 0x8b, "load: move r/m32 to r32"
mov, 0xa1, "mov dword from memory to eax. memory is specified by 32 bit displacement"
mov, 0xa3, "mov eax to dword in memory. memory is specified by 32 bit displacement"
mov, 0xb8+, "move imm32 to r32"
mov, 0xc6/0, "move imm8 to r/m8"
mov, 0xc7/0, "Move imm32 to r/m32"
movsx, 0x0fbe, "Move sign_extend(r/m8) to r32"
movzx, 0x0fb6, "Move zero_extend(r/m8) to r32"
movzx, 0x0fb7, "Move zero_extend(r/m16) to r32"

neg, 0xf7/3, "Negate r/m32"

pop, 0x58+, "Pop top of stack into r32"
popa, 0x61, "Pop all"
push, 0x50+, "Push r32 into the stack"
push, 0x68, "Push imm32 to the stack"
push, 0x6a, "Push imm8 to the stack"
push, 0xff/6, "Push r/m32 to the stack"
pusha, 0x60, "Push all"

ret, 0xc3, "Return to the caller"
setae, 0x0f93/x, "Set r/m8 if above or equal. Opextension is not specified in the doc"
sete, 0x0f94/x, "Set r/m8 if ZF. Opextension is not specified in the doc"
setg, 0x0f9f/x, "Set r/m8 if GF. Opextension is not specified in the doc"
setge, 0x0f9d/x, "Set r/m8 if GE. Opextension is not specified in the doc"
shl, 0xd3/4, "logical left shift: shift r/m32 left cl times"
sub, 0x29, "r/m32 - r32"
sub, 0x2b, "r32 - r/m32"
sub, 0x83/5, "Substract sign-extended imm8 from r/m32"
test, 0x84, "AND r8 with r/m8 (dst)"
test, 0x85, "AND r32 with r/m32 (dst)"


=========== below are for floating pointer instructions
fabs, 0xd9e1, "Replace ST(0) with its absolute value"
fadd, 0xdc/0, "Add m64fp to ST(0) and store result in ST(0)"
faddp, 0xdec0+, "Add ST(0) to ST(i) then pop"
fchs, 0xd9e0", "Change sign of ST(0)"
fcomip, 0xdff0+, "Set eflags base on 'ST(0) - ST(i)'. Then pop register stack"
fdiv, 0xdc/6, "Divide ST(0) by m64fp and store result in ST(0)"
# fdivp, 0xdef8+, "ST(i) = ST(i) / ST(0), then pop"
fdivrp, 0xdef0+, "ST(i) = ST(0) / ST(i), then pop. The mnemonic show in asm may be fdivp"
fild, 0xdb/0, "Push integer from m32int onto the FPU register stack"
fld, 0xdd/0, "Push m64fp onto the FPU register stack"
fld1, 0xd9e8, "Push +1.0 onto the FPU register stack"
fldz, 0xd9ee, "Push +0.0 onto the FPU register stack"
fmul, 0xdc/1, "Multiply ST(0) by m64fp and store result in ST(0)"
fstp, 0xdd/3, "Copy ST(0) to m64fp and pop register stack"
fstp, 0xddd8+, "Copy ST(0) to ST(i) and then pop"
fsub, 0xdc/4, "Subtract m64fp from ST(0) and store result in ST(0)"
fsubp, 0xdee8, "ST(i) = ST(0) - ST(i), then pop. The mnemonic show in asm may be fsubrp"
fxch, 0xd9c8+, "Exchange ST(0) and ST(i)"

