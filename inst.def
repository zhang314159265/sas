Name (as shown in Intel doc), OPCode (big endian), Description
(TODO: move content in this file to inst.inc gradually)
============
add, 0x01, "Add r32 to r/m32"
add, 0x05, "Add imm32 to eax"
add, 0x83/0, "Add sign extended imm8 to r/m32"
and, 0x25, "And imm32 and eax"
# and, 0x81/4, "And imm32 and r/m32"
and, 0x83/4, "And imm8 and r/m32 (sign-extended)"
call, 0xe8, "Call relative using 32 bit displacement"
cdq, 0x99, "Sign extend dword in eax to quadword in edx:eax."
cltd, 0x99, "alias to cdq"

cmovo, 0x0f40, "Conditional move r/m32 to r32 if cc=O. Check jcc disp8 for encoding of other comvcc instructions."

cmp, 0x39, "Compare 'r/m32 - r32'"
cmp, 0x3b, "Compare 'r32 - r/m32'"
cmp, 0x80/7, "Compare 'r/m8 - imm8'"
cmp, 0x83/7, "Compare 'r/m32 - imm8'"
div, 0xf7/6, "unsigned div by r/m32"
idiv, 0xf7/7, "signed div by r/m32"
imul, 0x0faf, "Signed multiply. Two-operand form. Multiply r32 (dst) and r/m32, store the truncated result back to r32"
int3, 0xcc, "trigger a breakpoint"
int, 0xcd, "imm8 represents the interrupt vector"

jo, 0x70, "relative jump using 8 bit displacement, if cc=O (OF=1)"
jno, 0x71, "relative jump using 8 bit displacement, if cc=NO (OF=0)"
jb, 0x72, "relative jump using 8 bit displacement, if cc=B (CF=1)"
jc, 0x72, "Alias to jb"
jnae, 0x72, "Alias to jb"
jae, 0x73, "relative jump using 8 bit displacement, if cc=AE (CF=0)"
jnb, 0x73, "Alias to jae"
jnc, 0x73, "Alias to jae"
je, 0x74, "relative jump using 8 bit displacement, if cc=E (ZF=1)"
jz, 0x74, "Alias to je"
jne, 0x75, "relative jump using 8 bit displacement, if cc=NE (ZF=0)"
jnz, 0x75, "Alias to jne"
jbe, 0x76, "relative jump using 8 bit displacement, if cc=BE (CF=1 or ZF=1)"
jna, 0x76, "alias to jbe"
ja, 0x77, "relative jump using 8 bit displacement, if cc=A (CF=0 and ZF=0)"
jnbe, 0x77, "Alias to ja"
js, 0x78, "relative jump using 8 bit displacement, if cc=S (SF=1)"
jns, 0x79, "relative jump using 8 bit displacement, if cc=NS (SF=0)"
jp, 0x7a, "relative jump using 8 bit displacement, if cc=P (PF=1)"
jpe, 0x7a, "Alias to jp. jpe means parity even"
jnp, 0x7b, "relative jump using 8 bit displacement, if cc=NP (PF=0)"
jpo, 0x7b, "Alias to jnp. jpo mean parity odd"
jl, 0x7c, "relative jump using 8 bit displacement, if cc=L (SF!=OF)"
jnge, 0x7c, "Alias to jl"
jge, 0x7d, "relative jump using 8 bit displacement, if cc=GE (SF=OF)"
jnl, 0x7d, "Alias to jge"
jle, 0x7e, "relative jump using 8 bit displacement if cc=LE (ZF=1 or SF!=OF)"
jng, 0x7e, "Alias to jle"
jg, 0x7f, "relative jump using 8 bit displacement, if cc=G (ZF=0 and SF=OF)"
jnle, 0x7f, "Alias to jg"

jo, 0x0f80, "relative jump using 32 bit displacement, if cc=O (OF=1). Check jcc disp8 for encoding of other jcc disp32 instructions."

jmp, 0xe9, "relative jump using 32 bit displacement"
jmp, 0xeb, "relative jump using 8 bit displacement"

lea, 0x8d, "Load the effective address of the memory operand to register"
leave, 0xc9, "Short cut for 'mov %ebp, %esp; pop %ebp'"
mov, 0x88, "store: move r8 to r/m8"
mov, 0x89, "store: move r32 to r/m32"
mov, 0x8b, "load: move r/m32 to r32"
mov, 0xa1, "mov dword from memory to eax. memory is specified by 32 bit displacement"
mov, 0xa3, "mov eax to dword in memory. memory is specified by 32 bit displacement"
mov, 0xb8+, "move imm32 to r32"
mov, 0xc6/0, "move imm8 to r/m8"
mov, 0xc7/0, "Move imm32 to r/m32"
movsx, 0x0fbe, "Move sign_extend(r/m8) to r32"
movzx, 0x0fb6, "Move zero_extend(r/m8) to r32"
movzx, 0x0fb7, "Move zero_extend(r/m16) to r32"

neg, 0xf7/3, "Negate r/m32"

pop, 0x58+, "Pop top of stack into r32"
popa, 0x61, "Pop all"
push, 0x50+, "Push r32 into the stack"
push, 0x68, "Push imm32 to the stack"
push, 0x6a, "Push imm8 to the stack"
push, 0xff/6, "Push r/m32 to the stack"
pusha, 0x60, "Push all"

ret, 0xc3, "Return to the caller"

seto, 0x0f90/x, "Set r/m8 if overflow (OF=1). The reg field in the ModR/M byte is not used for the setcc instruction and those opcode bits are ignored by the processor. Check jcc for encoding of other setcc instructions."

shl, 0xd3/4, "logical left shift: shift r/m32 left cl times"
sub, 0x29, "r/m32 - r32"
sub, 0x2b, "r32 - r/m32"
sub, 0x83/5, "Substract sign-extended imm8 from r/m32"
test, 0x84, "AND r8 with r/m8 (dst)"
test, 0x85, "AND r32 with r/m32 (dst)"


=========== below are for floating pointer instructions
fabs, 0xd9e1, "Replace ST(0) with its absolute value"
fadd, 0xdc/0, "Add m64fp to ST(0) and store result in ST(0)"
faddp, 0xdec0+, "Add ST(0) to ST(i) then pop"
fchs, 0xd9e0", "Change sign of ST(0)"
fcomip, 0xdff0+, "Set eflags base on 'ST(0) - ST(i)'. Then pop register stack"
fdiv, 0xdc/6, "Divide ST(0) by m64fp and store result in ST(0)"
# fdivp, 0xdef8+, "ST(i) = ST(i) / ST(0), then pop"
fdivrp, 0xdef0+, "ST(i) = ST(0) / ST(i), then pop. The mnemonic show in asm may be fdivp"
fild, 0xdb/0, "Push integer from m32int onto the FPU register stack"
fld, 0xdd/0, "Push m64fp onto the FPU register stack"
fld1, 0xd9e8, "Push +1.0 onto the FPU register stack"
fldz, 0xd9ee, "Push +0.0 onto the FPU register stack"
fmul, 0xdc/1, "Multiply ST(0) by m64fp and store result in ST(0)"
fstp, 0xdd/3, "Copy ST(0) to m64fp and pop register stack"
fstp, 0xddd8+, "Copy ST(0) to ST(i) and then pop"
fsub, 0xdc/4, "Subtract m64fp from ST(0) and store result in ST(0)"
fsubp, 0xdee8, "ST(i) = ST(0) - ST(i), then pop. The mnemonic show in asm may be fsubrp"
fxch, 0xd9c8+, "Exchange ST(0) and ST(i)"

